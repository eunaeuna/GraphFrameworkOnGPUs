Hornet \cite{green-hornet,hornet-repo} is a dynamic graph data structure designed for sparse data. Hornet shares many properties with CSR and can be considered a dynamic version of CSR. Specifically, for both CSR and Hornet the adjacency array for each vertex is a single compact array that allows accessing the neighbors of a vertex using sequential accesses. Further, CSR and Hornet store these adjacency arrays in compact format. %Unlike CSR which allocates an exact amount of memory for the adjacency arrays, Hornet uses a more advanced memory memory that allows the adjacency arrays to both grow and shrink based on the utilization. By default, Hornet over allocates memory and leaves empty edges at the tail of the adjacency array. The over allocated amount of memory is never twice the amount that is needed. In \cite{green-hornet} it was shown that on average the initial utilization of the adjacency array is roughly $70\%$.  Furthermore, whereas CSR allocates a single array for all the edges, Hornet uses a three tier data structures for memory management which allows for the adjacency arrays to grow and shrink without needing to restart the data structure as is required by CSR and COO. Hornet's memory memory manager greatly improves on its predecessor \cite{green-custinger}.


Hornet's algorithm library is HornetsNest. One of the key objectives in the design of Hornet and HornetsNest was programmer productivity, specifically the goal was to create a high performance graph frameworks for both static and dynamic graph problems where algorithms could be implemented in a short amount of time while achieving excellent performance. %This practical requirement came from implementing dynamic graph algorithms which are already challenging enough. The success of Hornet and HornetsNest depends on two critical factors: 1) abstracting way the details of the memory manager and the internals of the dynamic graph data structure and 2) creating a set of graph primitives that allow implementing a wide range of graph algorithms. 

These graph primitives are essentially $parallel for$ loops that enable simple traversal of the vertices and edges. The edge traversal operations are also supported by various load-balancing mechanisms that ensure that the execution of an algorithm can be easily extended to execute on the tens of thousands of threads available in modern GPU systems. From a productivity perspective, users do not need to understand the internal details of Hornet to achieve a high level of performance. %In fact, many algorithms that are part of the HornetsNest framework, such as Page Rank and connected components, were implemented in less than a day. For example, the Katz Centrality algorithm in \cite{green-katz} was implemented in less than 10 hours and was able to achieve over a $50\times$ speedup over a sequential execution.
Lastly, HornetsNest includes several graph primitives that are currently unique and cannot be found in most frameworks---namely, dynamic graph primitives such as $edgeInsertion$ and $edgeDeletion$ (both of which include batched versions that allow doing their respective operation concurrently on a large number of edges).

%Through these operations it is possible to implement with Hornet and HornetsNest high performance graph algorithms that are otherwise not possible. Specifically, any graph algorithm that requires updating the graph structure itself as part of the computation or requires rebuilding the graph at any phase are extremely challenging. A few examples include: finding the maximal k-core in a graph or decomposing a graph into components based on the k-core values \cite{green-kcore}, finding the maximal k-Trusss in a graph \cite{green-ktruss-hpec}, or simply for implementing algorithms for dynamic graphs such as betweenness centrality \cite{GreenStreaming}, Katz Centrality \cite{green-katz}, or triangle counting \cite{green-fast-exact-tri-counting}.



